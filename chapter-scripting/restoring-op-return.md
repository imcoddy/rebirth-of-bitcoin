# 恢复 OP_RETURN

众所周知，OP\_RETURN 是在比特币交易中创建不可靠输出和传送数据的最简单机制。这是一个历史悠久的历史，它是比特币历史上最严重的错误之一的根本原因，可以说也是一个政治足球，导致了伟大的山寨侨民的开始。比起通常所理解的，这是比特币拼图中更重要的部分。它的当前用法是它的潜力的一个子集，它也有点错误。让我们来看看历史。

## 原来的 OP\_RETURN

在开始时，脚本的执行工作与现在略有不同。在某些方面更原始。在其他人更符合原意。实际上，在使用 UTXO 的授权中涉及两个脚本。锁定脚本（也称为 scriptPubkey），在创建新的比特币输出时指定。解锁脚本（也称为 scriptSig）是在花费输出时创建的（用于创建另一个新输出）。首先执行解锁脚本，然后将作为其结果的堆栈作为输入提供给锁定脚本。将锁定脚本视为拼图，将解锁脚本视为拼图的解决方案。如果您能解决这个难题，您就有权使用比特币。

在最初的 BitCoin 中，这是在另一个操作码 OP\_CODESEPERATOR 的帮助下实现的。此操作代码限制了后续 OP\_CHECKSIG 操作在签名检查期间将涵盖的范围，即签名标记的交易的哪些部分。这是必要的，因为解锁脚本中通常有签名，锁定脚本中有 OP\_CHECKSIG。如果不创造悖论并且可能以我们所知的方式结束宇宙，签名就无法签署。将会发生两个脚本并将其转换为单个脚本，如下所示：

    Concatenate(unlockingScript | OP_CODESEPERATOR | locksScript)

然后执行单个脚本。

## 我可以把你所有的 Bitcoin 都搞砸了

这种安排有一个明显的错误。决定 “谜题” 是否已成功解决的原因是，如果在脚本执行结束时 1）它没有因错误而失败，并且 2）堆栈上剩余的顶部项目可以被解释为有效的布尔值'true ”。OP\_RETURN 没有改变这一点。它只是提前退出脚本并完成上述检查以确定脚本是否可用。但它忽略了在创建输出的（较早的）时刻在 UTXO 中设置一次的锁定脚本，以及任何人都可以创建以尝试花钱的解锁脚本。请考虑以下锁定脚本：

    <public_key> OP_CHECKSIG

这是原始的付费公钥密钥脚本模板。它 **应** 只能够通过提供有效的签名，你应该只能够提供，如果您有对应于公共密钥的私有密钥来解锁。在比特币的原始版本中，执行的内容如下所示：

    Concatenate连接(<signature> | OP_CODESEPERATOR | <public_key> OP_CHECKSIG)

只要签名有效，这样就可以正常工作，但您也可以这样做：

    Concatenate(OP_TRUE OP_RETURN | OP_CODESEPERATOR | <public_key> OP_CHECKSIG)

这会将 true 推送到堆栈然后退出脚本。永远不会执行签名检查，并且脚本被认为是有效的，因为顶部堆栈项是布尔值“true”。事实上，锁定脚本是什么并不重要。这种行为可以被利用来支付任何比特币。

中本聪注意到这一点并修复了它。但他修改得太匆忙了。修复是让 OP\_RETURN 始终退出并失败脚本。原因很可能是当时代码的结构。更好的解决方法是在解锁脚本中禁止 OP\_RETURN。或者确保它在解锁脚本中找到时总是退出并失败，但如果在锁定脚本中找到则表现正常。问题在于，通过连接脚本，脚本解释器没有简单的方法来知道它所在的部分. OP\_CODESEPERATOR 是一个有效的操作码，可以在锁定或解锁脚本的任何地方使用。它甚至可以使用多次。因此，遇到该操作代码并不是从解锁到锁定脚本的过渡的明确标记。

## 数据载体

及时前滚，调用脚本解释器的方式稍有改变。首先让我们指出脚本中不只有一个堆栈，有三个堆栈。主堆栈，alt 堆栈和 “if” 堆栈，用于确定代码中的条件分支是否被执行。在最初的实现中，因为它是引擎的单个执行，所以来自解锁脚本的所有三个结果堆栈都被传递到锁定脚本。这些天，两个脚本分别执行，只有解锁脚本中的主要堆栈内容被传递到锁定脚本。OP\_CODESEPERATOR 的功能现在被脚本执行引擎的语义所包含，所以它已经被废弃，虽然这并不是说它在其他方面没用，但这是另一个故事。

对于其中一个潜在用例而言，现在已经注意到了 OP\_RETURN，这使得输出可以证明是不可靠的。它的行为现在是硬编码的，如果找到并执行，脚本无论如何都会失败。这被认为是一个有用的属性，因为矿工永远不需要它来验证他们可以选择修剪它的未来交易。因此，这是一种在区块链中嵌入数据的有用方式，这种方式证明了它在某个时间点的存在，但却没有给矿工带来长期的存储负担。我们今天仍然这样使用它。它不是在区块链中存储数据的唯一方法，甚至可能不是最好的。但它现在是比特币 SV 的常见用例。

## 要解决它，我们必须打破它

那就对了。如果我们修复 OP\_RETURN，我们现在正在使用 OP\_RETURN 的方式将会被打破。但是不要太担心，这是一个简单的解决方案，我们现在就可以开始了。几乎 OP\_RETURN 的所有用法看起来都像这样：

    OP_RETURN <data>

大多数都具有零值，因此没有任何风险。但是，当原始功能恢复时，这种形式的 OP\_RETURN 脚本将变得可花费（由任何人）。不适用于现有的 OP\_RETURN 输出（有关基于 UTXO 高度的激活的说明，请参阅[本系列的第 3 部分](https://bitcoinsv.io/2019/07/26/utxo-height-based-activation-roadmap-to-genesis-part-3/)）。但对于新的。考虑上面的脚本以及以 OP\_TRUE 结尾的解锁脚本：

    OP_TRUE | OP_RETURN <data>

如你所见，任何人都可以花这个。这对于其他人来说是否重要，但这不是我们目前所假设和期望的行为。

## 行动呼吁

如果您是使用 OP\_RETURN 的应用程序开发人员，那么您现在可以做的事情非常简单，这将确保您的应用程序现在和 Genesis 升级后都能保持一致的行为。而不是使用 OP\_RETURN 启动脚本，而是使用 OP\_FALSE OP\_RETURN 启动它。包含此内容的锁定脚本在现在和 Genesis 升级后都会遇到此序列的操作码时始终会失败。以下是我们在上面展示的相同技术如何使用此操作码模式的示例：

    OP_TRUE | OP_FALSE OP_RETURN

正如我们可以看到顶部堆栈项是 OP\_FALSE 所以当我们遇到 OP\_RETURN 并退出脚本时，我们将查看顶部堆栈项，看到它不是布尔值'true'，并且脚本将被视为失败，就像一个旧学校 OP\_RETURN 交易。

比特币 SV v0.2.1 已于 2019 年 7 月 12 日发布，其中包含一项更改，以将此操作码模式识别为标准交易。因此，一旦大多数节点升级到此版本，应用程序应该没有功能差异。此外，该版本还将数据载体大小默认设置为 100kb，因此数据载体交易的传输将变得更加容易和可靠。

## 但是我的旧 OP\_RETURN 输出会有问题吗？

我之前提到过，这对现有的数据集来说不是问题。我已经写了 [一篇单独的文章](https://bitcoinsv.io/2019/07/26/utxo-height-based-activation-roadmap-to-genesis-part-3/) 来解释基于 UTXO 高度的激活，因为它是我们将用于创世纪升级所需的一些更改的机制。您可以在 [这里](https://bitcoinsv.io/2019/07/26/utxo-height-based-activation-roadmap-to-genesis-part-3/) 阅读它。简单地说，您的旧 OP\_RETURN 交易不会再像往常一样。

## 总结

上面的部分名为“行动呼吁”，这也正是本文的内容。您现在就可以更改代码，因为 OP\_FALSE OP\_RETURN 现在在功能上与简单的 OP\_RETURN 完全相同。您的应用越早支持它，您就可以越早忘记这件事。升级后，此脚本类型的行为不会被更改。所以请尽快更新您的软件。我们现在距离回归创世纪只有不到半年的时间了。在比特币 SV 以及钱包和应用程序生态系统中，有很多工作要做。我们可以现在先解决掉这个，从而把精力放在更多值得关注的东西上面。
